<ng-container [ngSwitch]="path"><ng-container *ngSwitchCase="&quot;api&quot;">
<p><a routerLink="/docs/">Home</a></p><h1>/api</h1><ul><li><a routerLink="/docs/api/v1">v1</a></li></ul>
</ng-container>
<ng-container *ngSwitchCase="&quot;api/v1/auth&quot;">
<p><a routerLink="/docs/">Home</a></p><h1>/<a routerLink="/docs/api">api</a>/<a routerLink="/docs/api/v1">v1</a>/auth</h1><ul><li><a routerLink="/docs/api/v1/auth/self">self</a></li></ul>
</ng-container>
<ng-container *ngSwitchCase="&quot;api/v1/auth/self&quot;">
<p><a routerLink="/docs/">Home</a></p><h1>/<a routerLink="/docs/api">api</a>/<a routerLink="/docs/api/v1">v1</a>/<a routerLink="/docs/api/v1/auth">auth</a>/self</h1><h2>GET</h2><p>Returns data describing the authentication context of the request.</p><h3>Examples</h3><p>Guest:</p><pre>GET /api/v1/auth/self
</pre><pre>{{ "{" }}
  "type": "Guest",
  "scope": "Default"
}
</pre><p>User (using a session cookie):</p><pre>GET /api/v1/auth/self
Cookie: sid=b8be19ef-2d61-44de-b7d2-9c34ccb8a763
</pre><pre>{{ "{" }}
  "type": "User",
  "scope": "Default",
  "user": {{ "{" }}
    "type": "User",
    "id": "9f310484-963b-446b-af69-797feec6813f",
    "display_name": {{ "{" }}
      "current": {{ "{" }}
        "value": "Demurgos"
      }
    }
  },
  "is_administrator": true
}
</pre><p>OAuth acess token:</p><pre>GET /api/v1/auth/self
Authorization: Bearer 5f6613eb-880f-4b01-8e71-96b644e4584f
</pre><pre>{{ "{" }}
  "type": "AccessToken",
  "scope": "Default",
  "client": {{ "{" }}
    "type": "OauthClient",
    "id": "d19e61a3-83d3-410f-84ec-49aaab841559",
    "key": "eternalfest@clients",
    "display_name": "Eternalfest"
  },
  "user": {{ "{" }}
    "type": "User",
    "id": "0d8d5067-5954-4930-94be-c1d09bf71903",
    "display_name": {{ "{" }}
      "current": {{ "{" }}
        "value": "Elseabora"
      }
    }
  }
}
</pre>
</ng-container>
<ng-container *ngSwitchCase="&quot;api/v1&quot;">
<p><a routerLink="/docs/">Home</a></p><h1>/<a routerLink="/docs/api">api</a>/v1</h1><ul><li><a routerLink="/docs/api/v1/auth">auth</a></li><li><a routerLink="/docs/api/v1/users">users</a></li></ul>
</ng-container>
<ng-container *ngSwitchCase="&quot;api/v1/users&quot;">
<p><a routerLink="/docs/">Home</a></p><h1>/<a routerLink="/docs/api">api</a>/<a routerLink="/docs/api/v1">v1</a>/users</h1><ul><li><a routerLink="/docs/api/v1/users/user-id">:user_id</a></li></ul>
</ng-container>
<ng-container *ngSwitchCase="&quot;api/v1/users/user-id&quot;">
<p><a routerLink="/docs/">Home</a></p><h1>/<a routerLink="/docs/api">api</a>/<a routerLink="/docs/api/v1">v1</a>/<a routerLink="/docs/api/v1/users">users</a>/:user_id</h1><h2>GET</h2><p>Returns user data.</p><h3>Examples</h3><pre>GET /api/v1/users/9f310484-963b-446b-af69-797feec6813f
</pre><pre>{{ "{" }}
  "type": "User",
  "id": "9f310484-963b-446b-af69-797feec6813f",
  "display_name": {{ "{" }}
    "current": {{ "{" }}
      "value": "Demurgos"
    }
  },
  "is_administrator": true,
  "links": {{ "{" }}
    "hammerfest_es": {{ "{" }}
      "current": null,
      "old": []
    },
    "hammerfest_fr": {{ "{" }}
      "current": {{ "{" }}
        "link": {{ "{" }}
          "time": "2017-05-25T23:12:50.000Z",
          "user": {{ "{" }}
            "type": "User",
            "id": "9f310484-963b-446b-af69-797feec6813f",
            "display_name": {{ "{" }}
              "current": {{ "{" }}
                "value": "Demurgos"
              }
            }
          }
        },
        "unlink": null,
        "user": {{ "{" }}
          "type": "HammerfestUser",
          "server": "hammerfest.fr",
          "id": "127",
          "username": "elseabora"
        }
      },
      "old": []
    },
    "hfest_net": {{ "{" }}
      "current": {{ "{" }}
        "link": {{ "{" }}
          "time": "2017-05-25T23:13:12.000Z",
          "user": {{ "{" }}
            "type": "User",
            "id": "9f310484-963b-446b-af69-797feec6813f",
            "display_name": {{ "{" }}
              "current": {{ "{" }}
                "value": "Demurgos"
              }
            }
          }
        },
        "unlink": null,
        "user": {{ "{" }}
          "type": "HammerfestUser",
          "server": "hfest.net",
          "id": "205769",
          "username": "Demurgos"
        }
      },
      "old": []
    },
    "twinoid": {{ "{" }}
      "current": {{ "{" }}
        "link": {{ "{" }}
          "time": "2020-10-26T18:53:14.493Z",
          "user": {{ "{" }}
            "type": "User",
            "id": "9f310484-963b-446b-af69-797feec6813f",
            "display_name": {{ "{" }}
              "current": {{ "{" }}
                "value": "Demurgos"
              }
            }
          }
        },
        "unlink": null,
        "user": {{ "{" }}
          "type": "TwinoidUser",
          "id": "38",
          "display_name": "Demurgos"
        }
      },
      "old": []
    }
  }
}
</pre>
</ng-container>
<ng-container *ngSwitchCase="&quot;app/config&quot;">
<p><a routerLink="/docs/">Home</a> | <a routerLink="/docs/app">Applications</a></p><h1>Application configuration</h1><p>Every Eternaltwin game or application must be able to be configured using
either  environment variables or a configuration file.</p><h2>Configuration format</h2><h3>Environment variable</h3><p>When using environment variables, use <code>UPPER_SNAKE_CASE</code>. Prefix all the
variables with an identifier unique to your application.</p><ul><li>Example: <code>NEOPARC_EXTERNAL_URI</code> to configure the external URI of Neoparc
(Dinoparc remake).</li></ul><h3>Configuration file</h3><p>Do not invent your own file format. Use either <code>.env</code> files, JSON files or
TOML files.</p><p>Provide an example configuration file in your repository.</p><h3>Zero configuration</h3><p>You may allow your application to start without any environement variable or
configuration file. Assume that the application is running locally in
development mode in such case.</p><h2>Runtime representation</h2><p>Your application must fully load the configuration during its initialization.</p><p>It must check that the configuration is valid and represent it as a single
value. Pick the representation that best suits your language, usually a class
instance. Avoid untyped maps.</p><p>The goal is to avoid ad-hoc configuration access: the rest of the application
should only use this configuration value.</p><h2>Configurable values</h2><p>This section contains a list of values the must configurable.</p><h3>Eternaltwin URI</h3><p>Eternaltwin URI, used for OAuth and the API.</p><p>Example values:</p><ul><li><code>http://localhost:50320/</code></li><li><code>https://eternal-twin.net/</code></li></ul><h3>Eternaltwin OAuth client id</h3><p>OAuth <code>client_id</code> for Eternaltwin.</p><p>Example values:</p><ul><li><code>eternalfest@clients</code></li><li><code>d19e61a3-83d3-410f-84ec-49aaab841559</code></li></ul><h3>Eternaltwin OAuth client secret</h3><p>OAuth <code>client_secret</code> for Eternaltwin.</p><p>Example values:</p><ul><li><code>dev_secret</code></li><li><code>8tbuCjaBVkL2HZDh7cH2m2Fdv3CSEgK8</code></li></ul><h3>External URI</h3><p>Public URI for the root of the application.</p><p>Example values:</p><ul><li><code>http://directquiz.localhost/</code></li><li><code>http://directquiz.eternal-twin.net/</code></li></ul>
</ng-container>
<ng-container *ngSwitchCase="&quot;app/etwin-api&quot;">
<p><a routerLink="/docs/">Home</a> | <a routerLink="/docs/app">Applications</a></p><h1>Eternaltwin API</h1><p>Eternaltwin exposes all its data through a REST API.
Some resources are protected and require the right authorization.</p><p>There are <a href="https://gitlab.com/eternal-twin/etwin/-/tree/master/clients">official clients</a>
for various platforms. You should use them instead of writing your own client:</p><ul><li><a href="https://gitlab.com/eternal-twin/etwin/-/tree/master/clients/kotlin">Kotlin</a></li><li><a href="https://gitlab.com/eternal-twin/etwin/-/tree/master/clients/php">PHP</a></li><li><a href="https://gitlab.com/eternal-twin/etwin/-/tree/master/clients/ruby">Ruby</a></li><li><a href="https://gitlab.com/eternal-twin/etwin/-/tree/master/clients/typescript">TypeScript</a></li></ul><p>See also <a href="https://gitlab.com/eternal-twin/etwin/-/tree/master/examples">the examples</a></p><p>These clients are not complte yet, help is welcome to improve them.</p><p>All the client support retrieving data about the current client and retrieving data about users
(enough to authenticate users with an OAuth access token).</p>
</ng-container>
<ng-container *ngSwitchCase="&quot;app/etwin-integration&quot;">
<p><a routerLink="/docs/">Home</a> | <a routerLink="/docs/app">Applications</a></p><h1>Eternaltwin Integration</h1><p>This section describes how to integrate Eternaltwin into your project's
repository. Integrating Eternaltwin to your repository allows you to run and
test your project using a locally installed version of the Eternaltwin website.</p><p>Eternaltwin is installed as a project-local Node package:</p><ul><li>it ensures all the contributors use the same version</li><li>the project is fully self-contained and does not require an internet
connection to run</li><li>if you have multiple projects on your computer, there are no conflicts: each
one has its own Eternaltwin version.</li></ul><p>The packaged version is not the full website (for example, it does not include
translations). It's a lightweight version specifically intended to be installed
inside other projects.</p><h2>System requirements</h2><p>You need the following tools on your system:</p><ul><li><a routerLink="/docs/tools/node">Node.js</a>: Version <code>14.13.1</code> or higher</li><li><a routerLink="/docs/tools/yarn">Yarn</a></li></ul><p>If your system is not a 64-bit Linux or Windows, you also need <a href="https://rustup.rs/">Rust</a> to
complete the installation by compiling part of the package. If you have a 64-bit Linux or Windows,
Rust is optional.</p><p><strong>ℹ</strong> Using <strong>npm</strong> as an alternative to <strong>yarn</strong> is not officially supported but should work.</p><h2>Configure your repository for Node packages</h2><p>Your repository must contain a <code>package.json</code> file at its root. It is a
manifest file containing metadata for Node.js.</p><p>If your project does not have a <code>package.json</code>, you may create one by running
the following command at the repo root and replying to the prompts:</p><pre>yarn init .
</pre><p>You may read the <a href="https://yarnpkg.com/configuration/manifest">Yarn</a> or
<a href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json">npm</a> documentation
if you wish to learn more about <code>package.json</code> files.</p><p>Below is an example minimal <code>package.json</code> file.</p><pre>{{ "{" }}
  "name": "myproject",
  "version": "0.0.1",
  "licenses": [
    {{ "{" }}
      "type": "AGPL-3.0-or-later",
      "url": "https://spdx.org/licenses/AGPL-3.0-or-later.html"
    }
  ],
  "private": true,
  "scripts": {{ "{" }}},
  "dependencies": {{ "{" }}},
  "devDependencies": {{ "{" }}}
}
</pre><p>Make sure to commit the <code>package.json</code> file.</p><h2>Install Eternaltwin inside your project</h2><p>Run the following command in the directory containing <code>package.json</code>:</p><pre>yarn add --dev @eternal-twin/cli
</pre><p>This will perform the following 3 actions:</p><ol><li>Update your <code>package.json</code> file to document the new dependency on the package <code>@eternal-twin/cli</code>.</li><li>Download the package (and its own dependencies) into the <code>node_modules</code> directory.</li><li>Create (or update) a <code>yarn.lock</code> file to remember the exact version of the dependencies that
were installed and prevent accidental regressions.</li></ol><p>Commit the <code>package.json</code> and <code>yarn.lock</code> files.</p><p>Do not commit the <code>node_modules</code> directory: add the <code>node_modules/</code> rule to your <code>.gitignore</code> file.</p><p>You now have to update your <code>package.json</code> file to expose the <code>etwin</code> command.
Add the entry <code>"etwin": "etwin"</code> to the <code>scripts</code> config in your <code>package.json</code>.
The resulting <code>package.json</code> should be similar to:</p><pre>{{ "{" }}
  "name": "myproject",
  "version": "0.0.1",
  "licenses": [
    {{ "{" }}
      "type": "AGPL-3.0-or-later",
      "url": "https://spdx.org/licenses/AGPL-3.0-or-later.html"
    }
  ],
  "private": true,
  "scripts": {{ "{" }}
    "etwin": "etwin"
  },
  "dependencies": {{ "{" }}},
  "devDependencies": {{ "{" }}
    "@eternal-twin/cli": "^0.8.3"
  }
}
</pre><p><strong>⚠ The package was previously named <code>@eternal-twin/website</code>, it was renamed to <code>@eternal-twin/cli</code>.</strong>
Make sure you use the right package.</p><h2>Configure Eternaltwin</h2><p>Before you can run Eternaltwin, you must configure it.</p><p>ℹ There is <a href="https://gitlab.com/eternal-twin/etwin/-/issues/20">an open issue</a> to
allow Eternaltwin to run without any configuration file.</p><p>The Eternaltwin configuration is loaded from a file named <code>etwin.toml</code>.</p><p>This file may contain configuration specific to your local machine and as such
should not be stored in Git. The recommended strategy to configure Eternaltwin
is the following:</p><ol><li>Create a file named <code>etwin.toml.example</code>.</li><li>Copy <a href="https://gitlab.com/eternal-twin/etwin/-/blob/master/etwin.toml.example">the official example configuration</a>
(<a href="https://gitlab.com/eternal-twin/etwin/-/raw/master/etwin.toml.example">raw</a>)
into <code>etwin.toml.example</code>. You do not need to customize the config yet.</li><li>Add the <code>etwin.toml</code> rule to your <code>.gitignore</code>, commit the file <code>etwin.toml.example</code></li><li>Update your project setup documentation: contributors should copy the file <code>etwin.toml.example</code>
into <code>etwin.toml</code> manually.</li><li>Copy your <code>etwin.toml.example</code> file into <code>etwin.toml</code>.</li></ol><h2>Start Eternaltwin</h2><p>Once Eternaltwin is installed and configured, you can run it from anywhere
inside your repo using the following command:</p><pre>yarn etwin
</pre><p>This command starts the local Eternaltwin server on your computer. You can
use this server to test your project.</p><p>When starting, the server displays the configuration it is using. You can use
this information to troubleshoot your configuration.</p><p>By default, the server uses the port <code>50320</code> and is available at the address
<a href="http://localhost:50320/">http://localhost:50320/</a>.</p><h2>Other commands</h2><p><code>yarn etwin</code> provides a couple subcommands:</p><ul><li><code>yarn etwin start</code>: Start the dev version of the website (default command, that's why <code>yarn etwin</code> also starts the website)</li><li><code>yarn etwin db check</code>: Check the state of the Postgres database used by the dev website if configured to use the <code>postgres</code> mode</li><li><code>yarn etwin db create</code>: Initialize an empty database</li><li><code>yarn etwin db upgrade</code>: Upgrade an existing database to the latest schema version</li></ul><h2>Next steps</h2><p>Now that your repo is configured to run Eternaltwin, you may start to actually
integrate your project with Eternaltwin. The first step would be to <a routerLink="/docs/app/etwin-oauth">use
Eternaltwin to manage user accounts through OAuth</a>.</p>
</ng-container>
<ng-container *ngSwitchCase="&quot;app/etwin-oauth&quot;">
<p><a routerLink="/docs/">Home</a> | <a routerLink="/docs/app">Applications</a></p><h1>Eternaltwin for OAuth</h1><h2>Technical information</h2><ul><li>Authorization endpoint: <code>/oauth/authorize</code></li><li>Token endpoint: <code>/oauth/token</code></li><li>Client ID: Displayed when starting <code>etwin</code>: <code>Id</code> or <code>Key</code> at your choice (<code>Key</code> is recommended)</li><li>Client secret: As configured in your <code>etwin.toml</code> file.</li></ul><h2>External documents</h2><ul><li><a href="https://tools.ietf.org/html/rfc6749">RFC 6749 - The OAuth 2.0 Authorization Framework</a></li><li><a href="https://auth0.com/docs/flows/authorization-code-flow">Auth0 documentation</a></li><li><a href="https://twinoid.com/developers/doc">Twinoid documentation</a></li></ul><h1>Registering the client</h1><p>The first step to use Eternaltwin as an OAuth provider is to register your game or app as a client.
This step is achieved through the <code>etwin.toml</code> configuration file (there is no web interface <em>yet</em>).</p><p>You must add an <a href="https://gitlab.com/eternal-twin/etwin/-/blob/master/etwin.toml.example#L34">OAuth client section</a>
and <strong>restart Eternaltwin</strong>.</p><p>Follow the documentation in the <code>etwin.toml</code> file. Here is an example:</p><pre>[clients.myproject]
display_name = "My Project"
app_uri = "http://localhost:8080"
callback_uri = "http://localhost:8080/oauth/callback"
secret = "dev_secret"
</pre><p>The key <code>myproject</code> is used as an internal identifier for your project.</p><p>The <code>display_name</code> and <code>app_uri</code> are not used yet, they are meant to
identify your app to users.</p><p>The <code>callback_uri</code> value is the absolute URI to your OAuth callback endpoint:
the URI where users are redirected back to your app with their authorization
code.</p><p><code>secret</code> defines the secret key shared between Eternaltwin and your OAuth
client. It is used when exchanging the authorization code for an access token.
When running your project locally, it is recommended to leave it as
<code>dev_secret</code>. When running in production, the secret is a long random string.</p><p>Restart your local Eternaltwin server to apply the changes. When Eternaltwin
starts, it prints details about the current configuration. You should see a
section for your OAuth client:</p><pre>myproject {{ "{" }}
  Id: 38f33c3f-db3b-49ce-81a7-597c97ba3162
  Key: myproject@clients
  Display name: My Project
  App URI: http://localhost:8080/
  Callback URI: http://localhost:8080/oauth/callback
}
</pre><p>The OAuth protocol referes to a <code>client_id</code> value used to identify your client.
Eternaltwin allows you to use either the <code>Id</code> field or the <code>Key</code> field as your
<code>client_id</code>. It is recommended to use the <code>Key</code> value as the <code>client_id</code>: the
<code>Id</code> changes every time the client is registered while the <code>Key</code> is stable.</p><h2>Acquiring the Access token</h2><p>OAuth is a standard protocol. You should check if your language has existing
libraries to help you acquiring the access token.</p><h3>User redirection</h3><p>Add a form on your app containing a single button <code>Sign-in with Eternaltwin</code>
and no text field (you may add some hidden fields as needed).
Clicking on this button should submit the form through POST to your own server.</p><p>The server should reply to this request with a redirection to the
Eternaltwin authorization endpoint: HTTP status code <code>302</code> with a <code>Location</code>
header.</p><p>The redirection URL is built with the following parameters:</p><table><tr><th>Name</th><th>Value</th></tr><tr><td>Origin</td><td>Eternaltwin <code>external_uri</code> config. <code>http://localhost:50320</code> by default during devlopment, <code>https://eternalfest.net</code> in production. Your app should get this value from the environment (config file, environment variable)</td></tr><tr><td>Pathname</td><td><code>/oauth/authorize</code></td></tr><tr><td><code>access_type</code> parameter</td><td>The string <code>offline</code></td></tr><tr><td><code>response_type</code> parameter</td><td>The string <code>code</code></td></tr><tr><td><code>client_id</code> parameter</td><td>Must match your client's <code>Id</code> or <code>Key</code> field (displayed when starting Eternaltwin)</td></tr><tr><td><code>redirect_uri</code> parameter</td><td>Must match the <code>callback_uri</code> field from the client registration.</td></tr><tr><td><code>scope</code> parameter</td><td>The empty string, or <code>base</code></td></tr><tr><td><code>state</code> parameter</td><td>A string holding your application state. It is recommeded to use a signed JWT</td></tr></table><p>Example:</p><pre>http://localhost:50320/oauth/authorize?access_type=offline&amp;response_type=code&amp;client_id=eternalfest%40clients&amp;redirect_uri=http%3A%2F%2Flocalhost%3A50313%2Foauth%2Fcallback&amp;scope=&amp;state=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdXRob3JpemF0aW9uU2VydmVyIjoiZXRlcm5hbC10d2luLm5ldCIsInJlcXVlc3RGb3JnZXJ5UHJvdGVjdGlvbiI6ImJkZWQyZDg5MWFlNDYwMTk2OWZhZmI0YjAxMmQ3ODZiIiwiaWF0IjoxNjA3OTU0NDExLCJleHAiOjE2MDgwNDA4MTF9.BRvm4D4Rfc2ZoHwlzLtEd3oiyJmxCq4eqPmxhYXRz7g
</pre><h3>User return</h3><p>Once Eternaltwin has authenticated the user, it is redirected back to your app
at the URI defined as the <code>callback_uri</code>.</p><p>Eternaltwin will append the following search parameters:</p><ul><li>In case of error:<ul><li><code>error</code>: See OAuth RFC</li><li><code>state</code></li></ul></li><li>In case of success:<ul><li><code>code</code>: The one-time authorization code</li><li><code>state</code></li></ul></li></ul><p>Example (success):</p><pre>http://localhost:50313/oauth/callback?code=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzY29wZXMiOlsiYmFzZSJdLCJpYXQiOjE2MDc5NTU4ODYsImV4cCI6MTYwNzk1NjE4NiwiYXVkIjpbIjhlNGY4MDY5LTRlN2MtNDkzYS1hYTA3LTNhNGFmNmIwYmZjNCIsImV0ZXJuYWxmZXN0QGNsaWVudHMiXSwiaXNzIjoiZXR3aW4iLCJzdWIiOiJkMTYxNjRhNC1hODliLTRhYzUtOGNkYS03ZDU1ZjkzMWFkYjgifQ.Vm-M5SfMjEHuRreRUzaMYJW0cUeIrlMwHIJP9fmFf_Y&amp;state=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdXRob3JpemF0aW9uU2VydmVyIjoiZXRlcm5hbC10d2luLm5ldCIsInJlcXVlc3RGb3JnZXJ5UHJvdGVjdGlvbiI6ImJkZWQyZDg5MWFlNDYwMTk2OWZhZmI0YjAxMmQ3ODZiIiwiaWF0IjoxNjA3OTU0NDExLCJleHAiOjE2MDgwNDA4MTF9.BRvm4D4Rfc2ZoHwlzLtEd3oiyJmxCq4eqPmxhYXRz7g
</pre><h3>Claiming the token</h3><p>On success, your <code>callback_uri</code> handler receives a one-time authorization code
(<code>code</code>). You can exchange this code for a long-term access token.</p><p>You app must perform a direct request to the Eternaltwin server (not a client
redirection).</p><table><tr><th>Name</th><th>Value</th></tr><tr><td>Method</td><td><code>POST</code></td></tr><tr><td>Origin</td><td>Eternaltwin <code>external_uri</code> config.</td></tr><tr><td>Pathname</td><td><code>/oauth/token</code></td></tr><tr><td><code>Authorization</code> header</td><td>Scheme: <code>Basic</code>, login: OAuth client <code>Id</code> or <code>Key</code>, password: <code>secret</code> field from the <code>etwin.toml</code></td></tr><tr><td><code>Content-type</code> header</td><td><code>application/json</code> or <code>application/x-www-form-urlencoded</code></td></tr><tr><td><code>code</code> request body field</td><td>The value of the one-time authorization code</td></tr><tr><td><code>grant_type</code> request body field</td><td>The string <code>authorization_code</code></td></tr></table><p>The Eternaltwin server will respond with the access token:</p><pre>{{ "{" }}
  access_token: "AMHILF5gGddDnfqVj9K8yIeP3VMIgaxG",
  refresh_token: "HfznfQUg1C2p87ESIp6WRq945ppG6swD",
  expires_in: 7200,
  token_type: "Bearer",
}
</pre><p>The value of the <code>access_token</code> field is the one you should use with API clients.</p><h2>Next steps</h2><p>The next step is usually to immediately use this <code>access_token</code> to get data about
the current user from the API and authenticate it.</p><p>See <a routerLink="/docs/app/etwin-api">using the Eternaltwin API</a>.</p>
</ng-container>
<ng-container *ngSwitchCase="&quot;app/guidelines&quot;">
<h1>Guidelines</h1><h2>License</h2><h3>Code</h3><p>All code in the Eternaltwin repositories should be licensed with the AGPL3 license:</p><ul><li>Full name: <code>GNU Affero General Public License v3.0 or later</code></li><li>Short name: <code>AGPL-3.0-or-later</code></li><li>SPDX link: <a href="https://spdx.org/licenses/AGPL-3.0-or-later.html">https://spdx.org/licenses/AGPL-3.0-or-later.html</a></li></ul><h3>Assets</h3><p>All other non-code assets should be licensed with the following Creative Commons 4.0 license:</p><ul><li>Full name: <code>Creative Commons Attribution Non Commercial Share Alike 4.0 International</code></li><li>Short name: <code>CC-BY-NC-SA-4.0</code></li><li>SPDX link: <a href="https://spdx.org/licenses/CC-BY-NC-SA-4.0.html">https://spdx.org/licenses/CC-BY-NC-SA-4.0.html</a></li></ul><h3>Other</h3><p>If you need another license, <a href="https://gitlab.com/eternal-twin/etwin/-/issues">open an issue</a>.</p><h2>Configuration</h2><p>Your application must have a mechanism to load configuration from the
environment variable or a configuration file. See <a routerLink="/docs/app/config">Application configuration</a>.</p>
</ng-container>
<ng-container *ngSwitchCase="&quot;app&quot;">
<p><a routerLink="/docs/">Home</a> | <a routerLink="/docs/app">Applications</a></p><h1>Application Development</h1><p>This section provides guides to help when developing Eternaltwin applications and games.</p><ul><li><a routerLink="/docs/app/guidelines">Guidelines</a></li><li><a routerLink="/docs/app/config">Application Configuration</a></li><li><a routerLink="/docs/app/etwin-integration">Eternaltwin integration</a></li><li><a routerLink="/docs/app/etwin-oauth">Eternaltwin for OAuth</a></li><li><a routerLink="/docs/app/etwin-api">Eternaltwin API</a></li></ul>
</ng-container>
<ng-container *ngSwitchCase="&quot;archive&quot;">
<h1>Archive</h1><p>This document describes the technical aspects of the Eternaltwin archive. The
archive is the component storing data from the official Motion Twin websites.
It's purpose is similar to the <a href="https://archive.org/web/">archive.org WaybackMachine</a> but
tailored for Motion Twin.</p><h2>Overview</h2><p>The archive is organized as a sequence of snapshots, updated when we get
responses from a Motion Twin server.</p><p>A snapshot is a group of data that remained the same over a consecutive period
of time. In addition to data itself, we add two extra fields: a time period
for our best guess when the data was valid and the set of timestamps when the
data was retrieved.</p><p><strong>Example</strong>: Every 5 minutes, we check the rank in the leaderboard for a given
Hammerfest player.</p><p>Here is a possible archive:</p><pre>period    | retrieved_at     | player_id | rank | score
----------|------------------|-----------|------|------
[ 0, 10[  | {{ "{" }}0, 5}           | 1         | 1    | 1000
[10, 15[  | {{ "{" }}10}             | 1         | 2    | 1000
[15, 35[  | {{ "{" }}15, 20, 25, 30} | 1         | 1    | 2000
[35, inf[ | {{ "{" }}35}             | 1         | 1    | 3000
</pre><p>The player was the best with a score of 1000, then someone else beat him, and
he fell to the second place. He then improved his score to 2000 (reclaiming the
first place), and after a while could improve it further to 3000.</p><h2>Uniqueness</h2><p>When presented with a new server response, there are two cases:</p><ul><li>The data is the same as the latest known state</li><li>The data is fresh (new or different)</li></ul><p>When we already had the data, there is nothing much to do apart from adding the
retrieval time to the <code>retrieved_at</code> set for the corresponding row.</p><p>When the data is fresh, the first step is to insert it as a new row. But we
also need to invalidate some other rows. The goal is to maintain
"point in time" uniqueness constraints.</p><p>If we continue from the example in the <em>Overview</em> section, the first
"point in time" constraint is "at any point in time, there is only one best
score per player". This is derived from the fact that if we only stored the
current state then <code>player_id</code> would be a primary key.
At the SQL level, this constraint can be directly enforced by the database
with a statement like "there are no two rows with the same <code>player_id</code> and
overlapping <code>period</code>".</p><p>After inserting a 5th fresh row, we could get:</p><pre>period    | retrieved_at     | player_id | rank | score
----------|------------------|-----------|------|------
[ 0, 10[  | {{ "{" }}0, 5}           | 1         | 1    | 1000
[10, 15[  | {{ "{" }}10}             | 1         | 2    | 1000
[15, 35[  | {{ "{" }}15, 20, 25, 30} | 1         | 1    | 2000
[35, inf[ | {{ "{" }}35}             | 1         | 1    | 3000
[40, inf[ | {{ "{" }}40}             | 1         | 1    | 4000
</pre><p>The row 4 and 5 are now in conflict: we must invalidate the 4th row.</p><p>Invalidating a row means setting the upper bound of its time period to a finite
value. In our case it produces:</p><pre>period    | retrieved_at     | player_id | rank | score
----------|------------------|-----------|------|------
[ 0, 10[  | {{ "{" }}0, 5}           | 1         | 1    | 1000
[10, 15[  | {{ "{" }}10}             | 1         | 2    | 1000
[15, 35[  | {{ "{" }}15, 20, 25, 30} | 1         | 1    | 2000
[35, 40[  | {{ "{" }}35}             | 1         | 1    | 3000
[40, inf[ | {{ "{" }}40}             | 1         | 1    | 4000
</pre><p>Invalidation occurs with any uniqueness constraint, not only with primary keys.
In our scenario, we should also enforce a "Point in Time" uniqueness on the
rank: no two players can be at the same rank at the same time.</p><p>To see the effect of multiple invalidations, lets start tracking the
player with id <code>2</code> now.</p><p>At time 45, we retrieve that he is in the second place with a score of 1500.
There is no conflict so far. We have multiple currently valid rows but they
refer to non-conflicting data so it's OK.</p><pre>period    | retrieved_at     | player_id | rank | score
----------|------------------|-----------|------|------
[ 0, 10[  | {{ "{" }}0, 5}           | 1         | 1    | 1000
[10, 15[  | {{ "{" }}10}             | 1         | 2    | 1000
[15, 35[  | {{ "{" }}15, 20, 25, 30} | 1         | 1    | 2000
[35, 40[  | {{ "{" }}35}             | 1         | 1    | 3000
[40, inf[ | {{ "{" }}40}             | 1         | 1    | 4000
[45, inf[ | {{ "{" }}45}             | 2         | 2    | 1500
</pre><p>At timee 50, we find out had he had very good run with a score 5000 and is now
at the top of the leaderboard. After adding the row we get:</p><pre>period    | retrieved_at     | player_id | rank | score
----------|------------------|-----------|------|------
[ 0, 10[  | {{ "{" }}0, 5}           | 1         | 1    | 1000
[10, 15[  | {{ "{" }}10}             | 1         | 2    | 1000
[15, 35[  | {{ "{" }}15, 20, 25, 30} | 1         | 1    | 2000
[35, 40[  | {{ "{" }}35}             | 1         | 1    | 3000
[40, inf[ | {{ "{" }}40}             | 1         | 1    | 4000
[45, inf[ | {{ "{" }}45}             | 2         | 2    | 1500
[50, inf[ | {{ "{" }}50}             | 2         | 1    | 5000
</pre><p>We have two conflicts now: we know that the score of the player 2 is no longer
1500 (primary key) but we also know that the player 1 can no longer be ranked
first. <strong>Inserting a single row may invalidate multiple rows.</strong></p><pre>period    | retrieved_at     | player_id | rank | score
----------|------------------|-----------|------|------
[ 0, 10[  | {{ "{" }}0, 5}           | 1         | 1    | 1000
[10, 15[  | {{ "{" }}10}             | 1         | 2    | 1000
[15, 35[  | {{ "{" }}15, 20, 25, 30} | 1         | 1    | 2000
[35, 40[  | {{ "{" }}35}             | 1         | 1    | 3000
[40, 50[  | {{ "{" }}40}             | 1         | 1    | 4000
[45, 50[  | {{ "{" }}45}             | 2         | 2    | 1500
[50, inf[ | {{ "{" }}50}             | 2         | 1    | 5000
</pre><p>At minute 55, we may wish to query the state of the player 1 again :</p><pre>period    | retrieved_at     | player_id | rank | score
----------|------------------|-----------|------|------
...
[40, 50[  | {{ "{" }}40}             | 1         | 1    | 4000
[45, 50[  | {{ "{" }}45}             | 2         | 2    | 1500
[50, inf[ | {{ "{" }}50}             | 2         | 1    | 5000
[55, inf[ | {{ "{" }}50}             | 1         | 3    | 4500
</pre><p>He improved its score to 4500, but due to the competition he is now at rank 3!.</p><h2>Periods as an optimization</h2><p>Let's focus on player 1 and ignore the rows from player 2:</p><pre>period    | retrieved_at     | player_id | rank | score
----------|------------------|-----------|------|------
[ 0, 10[  | {{ "{" }}0, 5}           | 1         | 1    | 1000
[10, 15[  | {{ "{" }}10}             | 1         | 2    | 1000
[15, 35[  | {{ "{" }}15, 20, 25, 30} | 1         | 1    | 2000
[35, 40[  | {{ "{" }}35}             | 1         | 1    | 3000
[40, 50[  | {{ "{" }}40}             | 1         | 1    | 4000
[40, 50[  | {{ "{" }}40}             | 1         | 1    | 4000
[55, inf[ | {{ "{" }}50}             | 1         | 3    | 4500
</pre><p>Notice that all the period are consecutive... except for a gap between minute
50 and 55! What was the state of the player at this point? We have no idea.</p><p>Actually it's worse than that. We have no idea about the state at minute 12.
The best score could still be 1000, or already be 2000, or be 1500 (and we
missed it by not querying the server at the right time).</p><p>Even in a single row we have this problem. Every week, Hammerfest scores are
reset. It's possible that this reset occured on minute 21 and the player
immediately played a run where he got a score of 2000. There was a reset, the
score changed to zero, but the archive missed it and did not even notice any
change!</p><p>The only instant when we actually know the state of player is the instant when
we retrieve it. Any state between two retrievals is only a guess.</p><p>This means that this whole representation with time periods is only an
optimization to avoid adding rows when the data does not change: the most
common case is for data to stay the same between two retrievals.</p><p>If we accept data duplication, we could use the following (strictly equivalent)
representation:</p><pre>retrieved_at | player_id | rank | score
-------------|-----------|------|------
0            | 1         | 1    | 1000
5            | 1         | 1    | 1000
10           | 1         | 2    | 1000
15           | 1         | 1    | 2000
20           | 1         | 1    | 2000
25           | 1         | 1    | 2000
30           | 1         | 1    | 2000
35           | 1         | 1    | 3000
40           | 1         | 1    | 4000
50           | 1         | 3    | 4500
</pre><h2>Partial views and shards</h2><p>Until now, we considered how to archive data from a single source: the highscore
page. When extracting data from the high-score page, we get
<code>(player_id, rank, score)</code> tuples as our input data.</p><p>We can also retrieve forum pages. On Hammerfest, each message has some
information about the author, in particular its rank and whether he retrieved
its carrot (has beaten the game). We can extract <code>(player_id, rank, has_carrot)</code>
tuples from forum pages.</p><p>This is a common situation: we want to get all the data about a player
<code>(player_id, rank, score, has_carrot)</code> but can only perform queries returning
partial results: either <code>(player_id, rank, score)</code> or
<code>(player_id, rank, has_carrot)</code>.</p><p>How should we archive such data where we only have access to partial views?</p><p>The solution is to list all the responses supported by the server:</p><ul><li><code>(player_id, rank, score)</code> (from the highscore page response)</li><li><code>(player_id, rank, has_carrot)</code> (from the forum page response)</li></ul><p>We then group the fields according to a Venn diagram of the sources. Each field
in the same region is grouped together:</p><pre>        +--------------------+
        |       score        |
  +-----+------------+       |
  |     | player_id  |       |
  |     | rank       |       |
  |     +------------+-------+
  |   has_carrot     |
  +------------------+
</pre><p>We augment each group with a primary key if needed. The result we get is what
we call shards:</p><ul><li><code>(player_id, rank)</code></li><li><code>(player_id, has_carrot)</code></li><li><code>(player_id, score)</code></li></ul><p>A <strong>shard</strong> is a group of data that can only change together. Data in a shard
is tracked together in the same table. Data in different shards
can be retrieved (and archived) at different independent moments.</p><p>In this case it means that we would have 3 tables in the database to archive
the response of these two kinds of pages.</p><p>Archiving a "highscore page response" now requires us to update the 2 shards
<code>(player_id, rank)</code> and <code>(player_id, score)</code>.</p><p>Archiving a "forum page response" now requires to update the 2 shards
<code>(player_id, rank)</code> and <code>(player_id, has_carrot)</code>.</p><p>Shards for the same response are updated in the same transaction.</p><h2>Pagination</h2><p>Another important source of partial knowledge is pagination. When viewing
paginated content such as a forum thread, we only get to see a small part of
it.</p><p>When later asked to return the state of a page at a given point in time, it is
important to be careful about how we model paginated content to avoid
returning a virtual page that could not have existed at the time. This is
especially important when elements can move or be deleted (e.g. the main
page of a forum section has a list of threads, this is a highly dynamic
paginated list).</p><p>The main issue is to represent empty list and detect item removals.
This is achieved by explicitly storing the list size along the items.</p><p>TODO: Expand on this section (example of the Twinoid comments).</p><h3>List</h3><p>The solution is to instead represent the highscore list directly even if it
involves creating more tables to support referential integrity.</p><p>We split it into shards as <code>(player, ladder_rank, score)</code> and
<code>(ladder_rank, highscore_list)</code> and then represent the <code>thread_list</code> as an
immutable collection.</p><pre>(player, ladder_rank, score)
period    | retrieved_at | player | ladder_rank | score
----------|--------------|--------|-------------|-------
[ 0, inf[ | {{ "{" }}0,5}        | 1      | 1           | 5000
[ 0, inf[ | {{ "{" }}0,5}        | 2      | 1           | 4500
[ 0, inf[ | {{ "{" }}0}          | 3      | 1           | 1000


(ladder_rank, highscore_list)
period    | retrieved_at | ladder_rank  | highscore_list
----------|--------------|--------------|--------------------------------------
[ 0, 5  [ | {{ "{" }}0}          | 1            | aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa
[ 5, inf[ | {{ "{" }}5}          | 1            | bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb

highscore_lists:
highscore_list
-------------------------------------
aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa
bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb

highscore_list_items:
highscore_list                       | player | offset
-------------------------------------|--------|--------
aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa | 1      | 0
aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa | 2      | 1
aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa | 3      | 2
bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb | 1      | 0
bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb | 2      | 1
</pre><h2>Upsertion query</h2><p><strong>⚠ This section is highly technical and describes how snapshot upsertion is
actually implemented. Feel free to skip it.</strong></p><p>Snapshots are inserted into shard within a single (but complex) query. It
ensures that each shard is updated atomically (even without transactions).</p><p>This sections describes this query. At the moment this article is written, the
upsertion query is defined through a Rust macro in <a href="https://gitlab.com/eternal-twin/etwin/-/blob/master/crates/postgres_tools/src/lib.rs"><code>crates/postgres_tools/src/lib.rs</code></a>.</p><p>The query uses a syntax called <a href="https://www.postgresql.org/docs/current/queries-with.html">Common Table Expression (CTE)</a>
to build the query from smaller parts.</p><ol><li><p><code>input_row</code>: The new snapshot we wish to insert, written as if the data is
fresh (new or different).</p><pre>input_row:

period    | retrieved_at     | player_id | x | y
----------|------------------|-----------|---|---
[40, inf[ | {{ "{" }}40}             | 1         | 3 | 7
</pre></li><li><p><code>current_row_primary</code> and <code>current_row_&lt;ukey&gt;</code>: For each "point in time"
uniqueness constraint (primary key and extra unique keys), check if we have
an already valid snaphot (with an infinite upper bound on the time period)
matching the key in <code>input_row</code>.
We only need to track the identity of such rows, hence why we only keep
the primary key and period.</p></li><li><p><code>matching_current_row</code>: At this step we take the intersection of all the rows
from step 2. If they are all the same row we also check if its data fields
are the same as the one from <code>input_row</code>.</p><p><code>matching_current_row</code> can contain only 0 or 1 row. If it has a row, this is
a pre-existing snapshot where the data fields are exactly the same as the
ones in <code>input_row</code>: the retrieved value is the same as the one we had.
If there is no row in <code>matching_current_row</code>, the <code>input_row</code> is new or
different (and may also invalidate some snapshots due to unique constraints).</p></li><li><p><code>missing_input_row</code>: Following the logic from the previous point we either:</p><ul><li>accept <code>input_row</code> as is and put in <code>missing_input_row</code> (if the data is
fresh / <code>matching_current_row</code> is empty)</li><li>reject <code>input_row</code> (by not putting it in <code>missing_input_row</code>) and will
update <code>matching_current</code> (it is non-empty).</li></ul></li><li><p><code>current_rows</code> and <code>rows_to_invalidate</code>: <code>current_rows</code> the union of the rows
from step 2, we then remove <code>matching_current_row</code> from them to get
<code>rows_to_invalidate</code>. <code>rows_to_invalidate</code> will either be empty or it will
be all the rows from <code>current_rows</code>. We either update <code>matching_current_row</code>
and there is no invalidation at all (because <code>matching_current_row</code> was
already present) or we invalidate all these rows because they had a common
unique key with <code>input_row</code> but differed in some other fields.</p></li></ol><p>At this point we have 3 categories of rows:</p><ul><li>Rows to <strong>update</strong>: if <code>matching_current_row</code> exists, only update its
<code>retrieved_at</code> field.</li><li>Rows to <strong>insert</strong> and <strong>invalidate</strong>: if <code>matching_current_row</code> does not
exist then insert <code>input_row</code> (through <code>maybe_input_row</code>) and invalidate the
rows from <code>rows_to_invalidate</code> by setting the upper bound of their time period
to the current time (so it is no longer infinite).</li></ul><p>These 3 categories are distinct and can be applied simultaneously. This is the
last step of the query. The top-level query aggregets the 3 mutating queries.</p><h2>Sampling window</h2><p>As we saw in the section "periods as an optimization", the representation we use
already tries to optimize space by reducing data duplication.</p><p>This representation is probably one of the most efficient to keep track of all
the data without any ambiguity.</p><p>What if we allowed to lose some of the data?</p><p>When retrieving archived data, we are mostly interested in the most recent
data. We may also be interested in historic data (after all it's the reason
why we keep a history). But we can probably get away with a less strict
tracking of our retrieval timestamps.</p><p>Here is our example from the start:</p><pre>period    | retrieved_at     | player_id | rank | score
----------|------------------|-----------|------|------
[ 0, 10[  | {{ "{" }}0, 5}           | 1         | 1    | 1000
[10, 15[  | {{ "{" }}10}             | 1         | 2    | 1000
[15, 35[  | {{ "{" }}15, 20, 25, 30} | 1         | 1    | 2000
[35, 40[  | {{ "{" }}35}             | 1         | 1    | 3000
[40, inf[ | {{ "{" }}40}             | 1         | 1    | 4000
</pre><p>The third row stores its timestamps: <code>{{ "{" }}15, 20, 25, 30}</code>. We can imagine a
data that changes fairly rarely but is found on many pages. In such a
scenario the set of timestamps can grow fairly large.</p><p>A solution to this is to apply a "sampling window". This operation ensures
that we only keep at most 2 timestamps per window of X units of time.</p><p>This allows to optimize retrieval sets when there is a quick burst of closely
related requests that leads to getting the same reply quite often.</p><p>For example if we take a window of <code>12 minutes</code> and apply it to the timestamps
from our third row, we see that when the window is between <code>14</code> and <code>26</code> minutes,
we have 3 points: <code>15</code>, <code>20</code> and <code>25</code>.</p><p>When there is an excess of values, the sampling window drops the ones in the
middle. The sampling window is applied from the smallest (oldest) to the
largest (most recent) values.</p><p>Applying a sampling window of 12 minutes to <code>{{ "{" }}15, 20, 25, 30}</code> reduces it
to <code>{{ "{" }}15, 25, 30}</code>.</p><p>It is shorter, but we lose the information that we queried the server at
minute 20.</p><p>It is currently still debated if a sampling window should be applied and how to
determine its size.</p>
</ng-container>
<ng-container *ngSwitchCase="&quot;db&quot;">
<p><a routerLink="/docs/">Home</a></p><h1>Database</h1><p>Eternaltwin uses Postgres as its main database.</p><h2>Initialize the Postgres cluster</h2><pre># Run as the Postgres user
initdb --locale "en_US.UTF-8" --encoding="UTF8" --pgdata="/var/lib/postgres/data/"
</pre><p>Example</p><pre>[postgres@red ~]$ initdb --locale "en_US.UTF-8" --encoding="UTF8" --pgdata="/var/lib/postgres/data/"
The files belonging to this database system will be owned by user "postgres".
This user must also own the server process.

The database cluster will be initialized with locale "en_US.UTF-8".
The default text search configuration will be set to "english".

Data page checksums are disabled.

fixing permissions on existing directory /var/lib/postgres/data ... ok
creating subdirectories ... ok
selecting dynamic shared memory implementation ... posix
selecting default max_connections ... 100
selecting default shared_buffers ... 128MB
selecting default time zone ... Europe/Paris
creating configuration files ... ok
running bootstrap script ... ok
performing post-bootstrap initialization ... ok
syncing data to disk ... ok

initdb: warning: enabling "trust" authentication for local connections
You can change this by editing pg_hba.conf or using the option -A, or
--auth-local and --auth-host, the next time you run initdb.

Success. You can now start the database server using:

    pg_ctl -D /var/lib/postgres/data/ -l logfile start

</pre><h2>Create a dev DB superuser</h2><pre># Run as the Postgres user
createuser --encrypted --interactive --pwprompt
</pre><p>Example</p><pre>postgres@host $ createuser --encrypted --interactive --pwprompt
Enter name of role to add: etwin.dev.admin
Enter password for new role: dev
Enter it again: dev
Shall the new role be a superuser? (y/n) y
</pre><h2>Create a DB</h2><pre>createdb --owner=&lt;dbuser&gt; &lt;dbname&gt;
psql &lt;dbname&gt;
ALTER SCHEMA public OWNER TO &lt;dbuser&gt;;
</pre><p>Example:</p><pre>$ createdb --owner=etwin.dev.admin etwin.dev
$ psql etwindb
psql (13.3)
Type "help" for help.

etwin.dev=# ALTER SCHEMA public OWNER TO "etwin.dev.admin";
</pre>
</ng-container>
<ng-container *ngSwitchCase="&quot;desktop&quot;">
<p><a routerLink="/docs/">Home</a></p><h1>Desktop Application</h1><p>Eternaltwin provides a desktop application. It allows you to play Motion Twin's Flash games.</p><h2>Download</h2><p>Latest version: 0.5.3 (2021-06-29)</p><ul><li><a href="https://gitlab.com/eternal-twin/etwin-app/-/jobs/artifacts/v0.5.3/raw/etwin-64bit.exe?job=release">Windows 64-bit installer</a></li><li><a href="https://gitlab.com/eternal-twin/etwin-app/-/jobs/artifacts/v0.5.3/raw/etwin-32bit.exe?job=release">Windows 32-bit installer</a></li><li><a href="https://gitlab.com/eternal-twin/etwin-app/-/jobs/artifacts/v0.5.3/raw/etwin.pacman?job=release">Linux - Pacman package</a></li><li><a href="https://gitlab.com/eternal-twin/etwin-app/-/jobs/artifacts/v0.5.3/raw/etwin.deb?job=release">Linux - Debian package</a></li><li><a href="https://gitlab.com/eternal-twin/etwin-app/-/jobs/artifacts/v0.5.3/raw/etwin.tar.gz?job=release">Linux - Archive</a></li><li><a href="https://eternal-twin.net/assets/app/v0.5.3/etwin.dmg">Mac installer</a></li></ul><h2>Contribute</h2><p><a href="https://gitlab.com/eternal-twin/etwin-app">Repository</a></p><p>The application is still in a beta state: please help us to improve it.</p><p>In particular, we need to ensure the app only tries to open trusted websites
(from Eternaltwin or Motion-Twin).</p><h2>Issues</h2><p>Report issues <a href="https://gitlab.com/eternal-twin/etwin-app/-/issues">on Gitlab</a>.</p>
</ng-container>
<ng-container *ngSwitchCase="&quot;&quot;">
<p><a routerLink="/docs/">Home</a></p><h1>Eternaltwin Documentation</h1><p>Welcome to the Eternaltwin documentation. This section describes various technical aspects relating to Eternaltwin.</p><h2>General</h2><ul><li><a routerLink="/docs/desktop">Desktop Application</a></li><li><a routerLink="/docs/api">API</a></li></ul><h2><a routerLink="/docs/app">Application development</a></h2><ul><li><a routerLink="/docs/app/guidelines">Guidelines</a></li><li><a routerLink="/docs/app/config">Application Configuration</a></li><li><a routerLink="/docs/app/etwin-integration">Eternaltwin integration</a></li><li><a routerLink="/docs/app/etwin-oauth">Eternaltwin for OAuth</a></li><li><a routerLink="/docs/app/etwin-api">Eternaltwin API</a></li></ul><h2><a routerLink="/docs/tools">Tools</a></h2><ul><li><a routerLink="/docs/tools/apache">Apache</a></li><li><a routerLink="/docs/tools/node">Node.js</a></li><li><a routerLink="/docs/tools/package-json">package.json</a></li><li><a routerLink="/docs/tools/yarn">Yarn</a></li></ul><h2>Other</h2><ul><li><a routerLink="/docs/oauth">OAuth</a></li><li><a routerLink="/docs/db">Postgres</a></li><li><a routerLink="/docs/server">Server</a></li></ul>
</ng-container>
<ng-container *ngSwitchCase="&quot;oauth&quot;">
<p><a routerLink="/docs/">Home</a></p><h1>Oauth</h1><p>Eternaltwin uses <a href="https://tools.ietf.org/html/rfc6749">the OAuth 2.0 authorization framework</a> to expose its data to the game websites.
Each game website is an OAuth 2 client.</p><h2>Client creation</h2><p>The first step is to create an OAuth client. It is not exposed publicly yet.</p><p>The creation options are:</p><ul><li>General information: display name, homepage URI</li><li>Technical: OAuth redirect (callback) URI</li></ul><p>The server creates the application and picks a random secret.
The secret is returned as clear-text in the creation response, it is never returned again.
The server treats the secret as a password and only stores its hash.</p><h2>Authorization request</h2><p>To authenticate a user, the client must redirect the end user to Eternaltwin to request its authorization.</p><p>The base URI is <code>https://eternal-twin.net/oauth/authorize</code>, with the following query parameters:</p><table><tr><th>Name</th><th>Description</th></tr><tr><td>client_id</td><td><strong>Required</strong>. Client ID received during the client creation</td></tr><tr><td>redirect_uri</td><td>Redirection URI. The default and only accepted value is the one configured during the app creation</td></tr><tr><td>login</td><td>Not yet implement: username to use by default</td></tr><tr><td>scope</td><td>Not yet implement: scopes to request</td></tr><tr><td>state</td><td>A string returned as-is</td></tr><tr><td>method</td><td>Authentication method suggestion if the user needs to sign-in (etwin, twinoid, hammerfest). Default: <code>etwin</code></td></tr></table><h2>Parameters</h2><h3>State</h3><p>The state parameter is a string returned as-is once the user has authenticated. It must include an unguessable part to prevent CSRF attacks.</p><p>For the system clients, we use a JWT based on <a href="https://tools.ietf.org/html/draft-bradley-oauth-jwt-encoded-state-00">this RFC draft</a> for the state. In particular, it has a "Request Forgery Protection" (<code>rfp</code>) field.</p><h3>Redirect URI</h3><p>Eternaltwin does not allow dynamic redirect URIs. Use the <code>state</code> parameter to encode state.</p><p>For the system clients, we use <code>https://&lt;game&gt;/oauth/callback</code> if the client supports only one authorization server (Eternaltwin), or <code>https://&lt;game&gt;/oauth/callback/&lt;as&gt;</code> where <code>as</code> is a string identifying the authorization server.</p>
</ng-container>
<ng-container *ngSwitchCase="&quot;server&quot;">
<h1>Server</h1><h2>Environment</h2><table><tr><th>Name</th><th>Version</th></tr><tr><td>JRE</td><td>16</td></tr><tr><td>Nginx</td><td>1.20</td></tr><tr><td>Node.js</td><td>14.13.1 or newer (at your choice)</td></tr><tr><td>PHP</td><td>8.0</td></tr><tr><td>Postgres</td><td>13.2</td></tr><tr><td>Ruby</td><td>2.7</td></tr></table><h2>Network</h2><ul><li>Internal name: <code>siman.eternal-twin.net</code></li><li>IPv4: <code>54.38.241.200</code></li><li>IPv6: <code>2001:41d0:305:2100::5e4</code></li></ul>
</ng-container>
<ng-container *ngSwitchCase="&quot;tools/apache&quot;">
<h1>Apache</h1><p><strong>⚠</strong> The server uses Nginx instead of Apache. You may still use Apache locally.</p><h2>Apache root</h2><ul><li>Wamp: <code>C:\wamp64\bin\apache\apache2.4.41</code> (the version may differ)</li><li>Xampp: TODO</li></ul><h2>Virtual Host</h2><p>Make sure that virtual host support is enabled in <code>./conf/httpd.conf</code>. The
following line should be uncommented:</p><pre>LoadModule vhost_alias_module modules/mod_vhost_alias.so
</pre><p>Add the following tag at the end of your <code>./conf/extra/httpd-vhosts.conf</code> file.</p><pre>&lt;VirtualHost *:80&gt;
  ServerName myproject.localhost
  ServerAlias myproject.localhost
  DocumentRoot "/path/to/project/"
  &lt;Directory "/"&gt;
    Require all granted
  &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</pre><p>Replace <code>myproject.localhost</code> by your project local domain name (as configured
in your hosts file).</p><p>Replace <code>/path/to/project/</code> by the absolute path to your project root.</p>
</ng-container>
<ng-container *ngSwitchCase="&quot;tools&quot;">
<p><a routerLink="/docs/">Home</a> | <a routerLink="/docs/tools">Tools</a></p><h1>Tools</h1><p>Help for the tools used around Eternaltwin.</p><ul><li><a routerLink="/docs/tools/apache">Apache</a></li><li><a routerLink="/docs/tools/node">Node.js</a></li><li><a routerLink="/docs/tools/package-json">package.json</a></li><li><a routerLink="/docs/tools/yarn">Yarn</a></li></ul>
</ng-container>
<ng-container *ngSwitchCase="&quot;tools/node&quot;">
<p><a routerLink="/docs/">Home</a> | <a routerLink="/docs/tools">Tools</a></p><h1>Node.js</h1><p><a href="https://nodejs.org/en/">Official website</a> | <a href="https://github.com/nodejs/node">GitHub</a></p><blockquote><p><strong>Node.js</strong> is an open-source, cross-platform, back-end, JavaScript runtime
environment that executes JavaScript code outside a web browser.</p></blockquote><p>Eternaltwin uses <strong>Node.js</strong> for its website and various command-line tools.</p><h2>Intallation</h2><p><strong>⚠</strong> Most projects require the version <code>14.13.1</code> or above.</p><h3>Linux or Mac</h3><ol><li><a href="https://github.com/nvm-sh/nvm#install--update-script">Install <code>nvm</code></a>.</li><li>Run <code>nvm install node</code>.</li></ol><p>Check your installation with <code>node --version</code>.</p><p><strong>⚠</strong> Most Linux distributions provide a <code>nodejs</code> or <code>node</code> package. This is a
system-level package intended as a dependency for other software. It is
recommended to avoid using this version: it requires <code>sudo</code> to install
global packages using <code>npm</code> and may be an older version that does not support
some projects.</p><h3>Windows</h3><p><a href="https://nodejs.org/en/download/">Download the Windows installer</a> and execute it.</p><p>Check your installation with <code>node --version</code>.</p>
</ng-container>
<ng-container *ngSwitchCase="&quot;tools/package-json&quot;">
<p>https://yarnpkg.com/configuration/manifest</p><p>TODO</p>
</ng-container>
<ng-container *ngSwitchCase="&quot;tools/yarn&quot;">
<p><a routerLink="/docs/">Home</a> | <a routerLink="/docs/tools">Tools</a></p><h1>Yarn</h1><p><a href="https://yarnpkg.com/">Official website</a> | <a href="https://github.com/yarnpkg/berry">GitHub</a></p><p><strong>Yarn</strong> is a modern package manager for <strong><a routerLink="/docs/tools/node">Node.js</a></strong> and the web.
Compared to other such package managers (e.g. <code>npm</code>), it is faster, more
reliable, and more flexible.</p><h2>Installation</h2><ol><li>Install <a routerLink="/docs/tools/node">Node.js</a></li><li>Run <code>npm install --global yarn</code></li><li>Check your installation with <code>yarn --version</code>.</li></ol>
</ng-container>
<ng-container *ngSwitchDefault=""><etwin-docs-not-found [path]="path"></etwin-docs-not-found></ng-container>
</ng-container>