use crate::metagen::core::{DisplayMgName, LowerSnake, MgSintType, MgType, MgUintType, PascalCase, TypeRegistry};
use std::fmt;
use std::path::PathBuf;

const KOTLIN_SINT: [(&str, MgSintType); 4] = [
  ("Byte", MgSintType::I8),
  ("Short", MgSintType::I16),
  ("Int", MgSintType::I32),
  ("Long", MgSintType::I64),
];

const KOTLIN_UINT: [(&str, MgUintType); 4] = [
  ("UByte", MgUintType::U8),
  ("UShort", MgUintType::U16),
  ("UInt", MgUintType::U32),
  ("ULong", MgUintType::U64),
];

const KOTLIN_INT: [&str; 8] = ["Byte", "Short", "Int", "Long", "UByte", "UShort", "UInt", "ULong"];

pub struct KotlinBackend {
  /// Root directory (e.g. `app/src/main/kotlin`)
  pub root: PathBuf,
  /// All the types will be in this group (package)
  pub group: Vec<String>,
}

impl KotlinBackend {
  pub fn new(root: PathBuf, group: Vec<String>) -> Self {
    Self { root, group }
  }
}

impl KotlinBackend {
  pub fn emit(&self, reg: &TypeRegistry) -> Result<(), anyhow::Error> {
    for (path, typ) in reg.paths() {
      let class_name = path.type_name().display::<PascalCase>();
      let mut package_name = self.group.clone();
      package_name.extend(path.group_names().iter().map(|n| n.display::<LowerSnake>().to_string()));
      let mut file = self.root.clone();
      file.extend(package_name.iter());
      let file = file.join(format!("{}.kt", class_name));
      let package_name = package_name.join(".");
      let full_class_name = format!("{}.{}", package_name, class_name);
      let file_content = match typ {
        MgType::String => todo!(),
        MgType::Uuid => todo!(),
        MgType::Uint(_) => todo!(),
        MgType::Sint(_) => todo!(),
        MgType::Unique(_, inner) => match inner.as_ref() {
          MgType::String => {
            let content = KotlinNewString {
              package: &package_name,
              class_name,
              full_class_name: &full_class_name,
            };
            content.to_string()
          }
          MgType::Uuid => {
            let content = KotlinNewUuid {
              package: &package_name,
              class_name,
              full_class_name: &full_class_name,
            };
            content.to_string()
          }
          MgType::Uint(typ) => {
            let content = KotlinNewUint {
              package: &package_name,
              class_name,
              full_class_name: &full_class_name,
              typ: *typ,
            };
            content.to_string()
          }
          MgType::Sint(typ) => {
            let content = KotlinNewSint {
              package: &package_name,
              class_name,
              full_class_name: &full_class_name,
              typ: *typ,
            };
            content.to_string()
          }
          MgType::Unique(_, _) => todo!(),
        },
      };
      std::fs::write(file, file_content)?;
    }
    Ok(())
  }
}

struct KotlinNewString<'typ> {
  package: &'typ str,
  class_name: DisplayMgName<'typ, PascalCase>,
  full_class_name: &'typ str,
}

impl<'typ> fmt::Display for KotlinNewString<'typ> {
  #[allow(clippy::write_with_newline)]
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(
      f,
      r#"// WARNING: DO NOT EDIT THE FILE MANUALLY!
// This file was auto-generated by `cargo xtask kotlin` from the definitions in `xtask/src/metagen/etwin.rs`.

package {package}

import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder

@Serializable(with = {class_name}.Serializer::class)
data class {class_name}(
  val inner: String,
) {{
  fun toDebugString(): String = "{class_name}(${{this}})"

  override fun toString(): String = this.inner

  object Serializer : KSerializer<{class_name}> {{
    override val descriptor: SerialDescriptor =
      PrimitiveSerialDescriptor("{full_class_name}", PrimitiveKind.STRING)

    override fun serialize(encoder: Encoder, value: {class_name}) =
      encoder.encodeString(value.inner)

    override fun deserialize(decoder: Decoder): {class_name} =
      {class_name}(decoder.decodeString())
  }}
}}
"#,
      package = self.package,
      class_name = self.class_name,
      full_class_name = self.full_class_name,
    )
  }
}

struct KotlinNewUuid<'typ> {
  package: &'typ str,
  class_name: DisplayMgName<'typ, PascalCase>,
  full_class_name: &'typ str,
}

impl<'typ> fmt::Display for KotlinNewUuid<'typ> {
  #[allow(clippy::write_with_newline)]
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(
      f,
      r#"// WARNING: DO NOT EDIT THE FILE MANUALLY!
// This file was auto-generated by `cargo xtask kotlin` from the definitions in `xtask/src/metagen/etwin.rs`.

package {package}

import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import java.util.UUID

@Serializable(with = {class_name}.Serializer::class)
data class {class_name}(
  val inner: UUID,
) {{
  constructor(value: String) : this(UUID.fromString(value))

  fun toDebugString(): String = "{class_name}(${{this}})"

  override fun toString(): String = this.inner.toString()

  object Serializer : KSerializer<{class_name}> {{
    override val descriptor: SerialDescriptor =
      PrimitiveSerialDescriptor("{full_class_name}", PrimitiveKind.STRING)

    override fun serialize(encoder: Encoder, value: {class_name}) =
      encoder.encodeString(value.inner.toString())

    override fun deserialize(decoder: Decoder): {class_name} =
      {class_name}(UUID.fromString(decoder.decodeString()))
  }}
}}
"#,
      package = self.package,
      class_name = self.class_name,
      full_class_name = self.full_class_name,
    )
  }
}

struct KotlinNewSint<'typ> {
  package: &'typ str,
  class_name: DisplayMgName<'typ, PascalCase>,
  full_class_name: &'typ str,
  typ: MgSintType,
}

impl<'typ> fmt::Display for KotlinNewSint<'typ> {
  #[allow(clippy::write_with_newline)]
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let (kt_typ, _) = std::array::IntoIter::new(KOTLIN_SINT)
      .find(|(_, range)| self.typ.can_convert_to(*range))
      .unwrap();

    write!(
      f,
      r#"// WARNING: DO NOT EDIT THE FILE MANUALLY!
// This file was auto-generated by `cargo xtask kotlin` from the definitions in `xtask/src/metagen/etwin.rs`.

package {package}

import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder

@Serializable(with = {class_name}.Serializer::class)
data class {class_name}(
  val inner: {kt_typ},
) {{
"#,
      package = self.package,
      class_name = self.class_name,
      kt_typ = kt_typ,
    )?;

    for (i, r) in std::array::IntoIter::new(KOTLIN_SINT) {
      if i == kt_typ || !r.can_convert_to(self.typ) {
        continue;
      }
      writeln!(
        f,
        "  constructor(value: {int}): this(value.to{kt_typ}())\n",
        int = i,
        kt_typ = kt_typ
      )?;
    }
    for i in std::array::IntoIter::new(KOTLIN_INT) {
      write!(f, "  fun to{int}(): {int} = this.inner", int = i)?;
      if i != kt_typ {
        write!(f, ".to{}()", i)?;
      }
      write!(f, "\n")?;
    }
    write!(f, "\n  companion object {{\n")?;
    for i in std::array::IntoIter::new(KOTLIN_INT) {
      write!(f, "    @JvmStatic\n")?;
      write!(
        f,
        "    fun from{int}(value: {int}): {class_name} = {class_name}(value",
        int = i,
        class_name = self.class_name,
      )?;

      if i != kt_typ {
        write!(f, ".to{}()", kt_typ)?;
      }

      write!(f, ")\n")?;
    }
    write!(f, "  }}\n")?;

    write!(
      f,
      r#"
  fun toDebugString(): String = "{class_name}(${{this}})"

  override fun toString(): String = this.inner.toString()

  object Serializer : KSerializer<{class_name}> {{
    override val descriptor: SerialDescriptor =
      PrimitiveSerialDescriptor("{full_class_name}", PrimitiveKind.LONG)

    override fun serialize(encoder: Encoder, value: {class_name}) =
      encoder.encodeLong(value.inner.toLong())

    override fun deserialize(decoder: Decoder): {class_name} =
      fromLong(decoder.decodeLong())
  }}
}}
"#,
      class_name = self.class_name,
      full_class_name = self.full_class_name,
    )
  }
}

struct KotlinNewUint<'typ> {
  package: &'typ str,
  class_name: DisplayMgName<'typ, PascalCase>,
  full_class_name: &'typ str,
  typ: MgUintType,
}

impl<'typ> fmt::Display for KotlinNewUint<'typ> {
  #[allow(clippy::write_with_newline)]
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let (kt_typ, _) = std::array::IntoIter::new(KOTLIN_UINT)
      .find(|(_, range)| self.typ.can_convert_to(*range))
      .unwrap();

    write!(
      f,
      r#"// WARNING: DO NOT EDIT THE FILE MANUALLY!
// This file was auto-generated by `cargo xtask kotlin` from the definitions in `xtask/src/metagen/etwin.rs`.

package {package}

import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder

@Serializable(with = {class_name}.Serializer::class)
data class {class_name}(
  val inner: {kt_typ},
) {{
"#,
      package = self.package,
      class_name = self.class_name,
      kt_typ = kt_typ,
    )?;

    for (i, r) in std::array::IntoIter::new(KOTLIN_UINT) {
      if i == kt_typ || !r.can_convert_to(self.typ) {
        continue;
      }
      write!(
        f,
        "  constructor(value: {int}): this(value.to{kt_typ}())\n",
        int = i,
        kt_typ = kt_typ
      )?;
    }
    for i in std::array::IntoIter::new(KOTLIN_INT) {
      write!(f, "  fun to{int}(): {int} = this.inner", int = i,)?;
      if i != kt_typ {
        write!(f, ".to{}()", i)?;
      }
      write!(f, "\n")?;
    }
    write!(f, "\n  companion object {{\n")?;
    for i in std::array::IntoIter::new(KOTLIN_INT) {
      write!(f, "    @JvmStatic\n")?;
      write!(
        f,
        "    fun from{int}(value: {int}): {class_name} = {class_name}(value",
        int = i,
        class_name = self.class_name,
      )?;

      if i != kt_typ {
        write!(f, ".to{}()", kt_typ)?;
      }

      write!(f, ")\n")?;
    }
    write!(f, "  }}\n")?;

    write!(
      f,
      r#"
  fun toDebugString(): String = "{class_name}(${{this}})"

  override fun toString(): String = this.inner.toString()

  object Serializer : KSerializer<{class_name}> {{
    override val descriptor: SerialDescriptor =
      PrimitiveSerialDescriptor("{full_class_name}", PrimitiveKind.LONG)

    override fun serialize(encoder: Encoder, value: {class_name}) =
      encoder.encodeLong(value.inner.toLong())

    override fun deserialize(decoder: Decoder): {class_name} =
      fromLong(decoder.decodeLong())
  }}
}}
"#,
      class_name = self.class_name,
      full_class_name = self.full_class_name,
    )
  }
}
