use crate::metagen::core::{DisplayMgName, MgType, PascalCase, TypeRegistry};
use std::fmt;
use std::path::PathBuf;

pub struct PhpBackend {
  /// Root directory (e.g. `app/src/main/kotlin`)
  pub root: PathBuf,
  /// All the types will be in this group (namespace)
  pub group: Vec<String>,
}

impl PhpBackend {
  pub fn new(root: PathBuf, group: Vec<String>) -> Self {
    Self { root, group }
  }
}

impl PhpBackend {
  pub fn emit(&self, reg: &TypeRegistry) -> Result<(), anyhow::Error> {
    for (path, typ) in reg.paths() {
      let class_name = path.type_name().display::<PascalCase>();
      let mut namespace_name = self.group.clone();
      namespace_name.extend(path.group_names().iter().map(|n| n.display::<PascalCase>().to_string()));
      let mut file = self.root.clone();
      file.extend(path.group_names().iter().map(|n| n.display::<PascalCase>().to_string()));
      let file = file.join(format!("{}.php", class_name));
      let namespace_name = namespace_name.join("\\");
      let file_content = match typ {
        MgType::String => todo!(),
        MgType::Uuid => todo!(),
        MgType::Uint(_) => todo!(),
        MgType::Sint(_) => todo!(),
        MgType::Unique(_, inner) => match inner.as_ref() {
          MgType::String => {
            let content = PhpNewString {
              namespace: &namespace_name,
              class_name,
            };
            content.to_string()
          }
          MgType::Uuid => {
            let content = PhpNewUuid {
              namespace: &namespace_name,
              class_name,
            };
            content.to_string()
          }
          MgType::Uint(_) => continue,
          MgType::Sint(_) => continue,
          MgType::Unique(_, _) => todo!(),
        },
      };
      std::fs::create_dir_all(file.parent().unwrap())
        .and_then(|()| std::fs::write(file.as_path(), file_content))
        .map_err(|_| anyhow::Error::msg(format!("FailedToWrite: {}", file.display())))?;
    }
    Ok(())
  }
}

struct PhpNewString<'typ> {
  namespace: &'typ str,
  class_name: DisplayMgName<'typ, PascalCase>,
}

impl<'typ> fmt::Display for PhpNewString<'typ> {
  #[allow(clippy::write_with_newline)]
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(
      f,
      r#"<?php declare(strict_types=1);

// WARNING: DO NOT EDIT THE FILE MANUALLY!
// This file was auto-generated by `cargo xtask php` from the definitions in `xtask/src/metagen/etwin.rs`.

namespace {namespace};

final class {class_name} implements \JsonSerializable {{
  private string $inner;

  final public function __construct(string $inner) {{
    $this->inner = $inner;
  }}

  final public function getInner(): string {{
    return $this->inner;
  }}

  final public function toString(): string {{
    return $this->inner;
  }}

  final public function __toString(): string {{
    return $this->toString();
  }}

  final public function jsonSerialize(): string {{
    return $this->inner;
  }}

  /**
   * @param mixed $raw
   * @return self
   */
  final public static function jsonDeserialize($raw): self {{
    return new self($raw);
  }}
}}
"#,
      namespace = self.namespace,
      class_name = self.class_name,
    )
  }
}

struct PhpNewUuid<'typ> {
  namespace: &'typ str,
  class_name: DisplayMgName<'typ, PascalCase>,
}

impl<'typ> fmt::Display for PhpNewUuid<'typ> {
  #[allow(clippy::write_with_newline)]
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(
      f,
      r#"<?php declare(strict_types=1);

// WARNING: DO NOT EDIT THE FILE MANUALLY!
// This file was auto-generated by `cargo xtask php` from the definitions in `xtask/src/metagen/etwin.rs`.

namespace {namespace};

use Ramsey\Uuid\Uuid;
use Ramsey\Uuid\UuidInterface;

final class {class_name} implements \JsonSerializable {{
  private UuidInterface $inner;

  final public function __construct(UuidInterface $inner) {{
    $this->inner = $inner;
  }}

  final public function getInner(): UuidInterface {{
    return $this->inner;
  }}

  final public function jsonSerialize(): string {{
    return $this->inner->jsonSerialize();
  }}

  final public function toString(): string {{
    return $this->inner->toString();
  }}

  final public function __toString(): string {{
    return $this->toString();
  }}

  final public static function fromString(string $raw): self {{
    return new self(Uuid::fromString($raw));
  }}

  /**
   * @param mixed $raw
   * @return self
   */
  final public static function jsonDeserialize($raw): self {{
    return self::fromString($raw);
  }}
}}
"#,
      namespace = self.namespace,
      class_name = self.class_name,
    )
  }
}
